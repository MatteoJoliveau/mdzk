'\" t
.\" Automatically generated by Pandoc 2.14.0.3
.\"
.TH "mdzk documentation" "" "" "" ""
.hy
.PP
This document will go through how mdzk operates and how you can use it
in your workflows.
Currently, it is quite limited, as mdzk is still under heavy
development.
If you have any suggestions to things that should be added, open an
issue on our GitHub (https://github.com/mdzk-rs/mdzk/issues/new)
describing it and mark it with the \f[C]documentation\f[R] label.
Any contributions are of course welcome.
.PP
   *   *   *   *   *
.SH Installing
.PP
You can install mdzk from multiple package managers:
.PP
.TS
tab(@);
l r.
T{
\ Source
T}@T{
\ Installation command
T}
_
T{
\ AUR (https://aur.archlinux.org/packages/mdzk/) (with
Paru (https://github.com/Morganamilo/paru))
T}@T{
\f[C]paru -S mdzk\f[R]
T}
T{
\ Crates.io (https://crates.io/crates/mdzk)
T}@T{
\f[C]cargo install mdzk\f[R]
T}
T{
\ Homebrew (https://formulae.brew.sh/formula/mdzk#default)
T}@T{
\f[C]brew install mdzk\f[R]
T}
T{
\ Nix (https://search.nixos.org/packages?channel=unstable&show=mdzk&from=0&size=50&sort=relevance&type=packages&query=mdzk)
T}@T{
\f[C]nix run nixpkgs#mdzk -- <command>\f[R]
T}
.TE
.PP
There is also a range of pre-built binaries available through the
release page on GitHub (https://github.com/mdzk-rs/mdzk/releases).
.SS Build mdzk yourself
.PP
If you want the latest and greatest, you can build mdzk from scratch by
cloning the repo and building using Rust
tooling (https://www.rust-lang.org/tools/install):
.IP
.nf
\f[C]
$ git clone https://github.com/mdzk-rs/mdzk.git
$ cd mdzk
$ cargo build --release
\f[R]
.fi
.PP
An mdzk binary for your system will now be available in
\f[C]./target/release\f[R].
.PP
   *   *   *   *   *
.SH Core concepts
.PP
At it\[cq]s core, mdzk operates on a \f[I]vault\f[R] with
\f[I]notes\f[R] containing optional \f[I]internal links\f[R].
Let\[cq]s unpack these terms:
.IP \[bu] 2
A \f[B]vault\f[R] is a directed
graph (https://en.wikipedia.org/wiki/Directed_graph).
.IP \[bu] 2
\f[B]Notes\f[R] are the nodes in a vault.
.IP \[bu] 2
\f[B]Internal links\f[R] create edges connecting each note.
.PP
In the filesystem, a vault is represented by directory, the notes being
Markdown-files.
mdzk takes a directory as input, recursively finds any Markdown-files in
it and loads each of them as a node in the graph.
It then parses every file and establishes edges between the nodes based
on the links contained in it.
.PP
The \f[I]vault\f[R] data structure is a very efficient and useful
concept in dealing with notes and their relation together.
mdzk models a vault as an adjacency
matrix (https://mathworld.wolfram.com/AdjacencyMatrix.html) and does
custom hashing on each note to obtain unique note IDs.
This means that we get incredibly fast lookups on note adjacencies.
.SS Vaults
.PP
As a user, you can think of a vault simply as a directory with a bunch
of Markdown-files.
You may structure this directory however you want and include any other
filetypes - mdzk does not care.
The major difference to keep in mind, is that a vault does not include
the notion of any hierarchy.
You may bury a note in a subdirectory of a subdirectory of a
subdirectory if you want, mdzk will still handle it the same way as a
note placed in the root.
.PP
Consider the vault with the following tree:
.IP
.nf
\f[C]
\&.
\[u251C]\[u2500]\[u2500] sub
\[br]  \[u251C]\[u2500]\[u2500] subsub
\[br]  \[br]  \[u2514]\[u2500]\[u2500] note-0.md
\[br]  \[u2514]\[u2500]\[u2500] note-1.md
\[u2514]\[u2500]\[u2500] note-2.md
\f[R]
.fi
.PP
Producing a visualization of this vault, might look like this:
.PP
[IMAGE: image]
.PP
As you can see, the paths were totally ignored; \f[I]internal links are
the only constructs that define the vault structure\f[R].
The filepaths are still stored as metadata, so custom workflows using
directory hierarchies can still be made if one wants.
.SS Notes
.SS Internal links
.PP
   *   *   *   *   *
.SH Vault JSON representation
.IP
.nf
\f[C]
{
  \[dq]notes\[dq]: [
    {
      // A unique ID, formatted as a hex digit
      \[dq]id\[dq]: string,

      // The given title, taken from the filename or
      // explicitly set via front matter
      \[dq]title\[dq]: string,

      // A relative path from the vault root to the note
      \[dq]path\[dq]: string | null,

      // A set of tags set for the note
      \[dq]tags\[dq]: [string],

      // RFC3339-formatted datestring
      \[dq]date\[dq]: string | null,

      // The original content of the source file that
      // produced this note
      \[dq]original-content\[dq]: string,

      // The content of the note. All internal links are
      // converted to CommonMark and the front matter
      // is stripped.
      \[dq]content\[dq]: string,

      // A set of note IDs, each representing an
      // outgoing internal link
      \[dq]links\[dq]: [string],

      // A set of note IDs, each representing an
      // incoming internal link
      \[dq]backlinks\[dq]: [string]
    }
  ],
  // Not yet implemented: \[dq]tags\[dq]: []
}
\f[R]
.fi
